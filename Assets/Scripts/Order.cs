using Assets.Scripts;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

public class Order
{
    public string Title;
    public string Description;    
    public bool Movable;
    public bool PassiveRunning;
    public int Range;
    public int Regenerate;
    public int Uses;
	public int NoiseGeneration;
	public int MaxUses;
    public TargetType Targeting;
	public Action<Selectable, Selectable> ActiveAction;
    public Action<Selectable> PassiveAction;
    public Func<Selectable, Selectable, Boolean> Usable;
	public Func<Selectable, Selectable, Boolean> ValidTarget;
    public OrderLevel NecessaryOrderLevel;
}

public class CoverOrder : Order
{
    public Cover CoverBonus;    
}


public static class OrderStatic
{
    private static void noisening(Selectable sourceUnit, int noiseStrength)
    {
        //List<double[]> noiseResTest = MainBehaviour.MakeNoise(sourceUnit, Math.Min(sourceUnit.GetComponent<UnitBehaviour>().currentAttackStrength, MainBehaviour.maxNoiseStrength));
		List<double[]> noiseResTest = MainBehaviour.MakeNoise(sourceUnit, Math.Min(noiseStrength, MainBehaviour.maxNoiseStrength));
        foreach (double[] inNoiseWave in noiseResTest)
        {
            HexKey key = new HexKey(Convert.ToInt32(inNoiseWave[0]), Convert.ToInt32(inNoiseWave[1]));

            if (GameFieldBehaviour.GetMapCost(key) == -1)
            {
                continue;
            }
            HexTileBehaviour tile = GameFieldBehaviour.hexTiles[key] as HexTileBehaviour;
            if (tile == null)
            {
                continue;
            }
            tile.noise += inNoiseWave[2];
        }
    }

    public static bool SameFlags(this OrderLevel self, OrderLevel target)
    {
        return ((int)(self & target) > 0);
    }

	public static bool SameFlags(this TargetType self, TargetType target)
	{
		return (((int)self & (int)target) > 0);
	}

    private static void KillUnit(Selectable unitToDie)
    {
        unitToDie.GetComponent<UnitBehaviour>().hexPosition.containedUnit = null;
        PlayerBehaviour unitTeam = unitToDie.team.GetComponent<PlayerBehaviour>();
        unitTeam.units.Remove(unitToDie);
        UnityEngine.Object.Destroy(unitToDie.gameObject);

		if (
			//unitTeam.land.Count <= 0 ||
		    unitTeam.land.FirstOrDefault(mb => mb.name == "Base") == null)
        {
            unitTeam.lost = true;
        }
    }

	private static void captureLand(Selectable capturingUnit)
	{
		HexTileBehaviour capturedTile =	capturingUnit.GetComponent<UnitBehaviour>().hexPosition;
		PlayerBehaviour oldTileTeam = capturedTile.GetComponent<Selectable>().team.GetComponent<PlayerBehaviour>();

		Selectable capturedTileSBH = capturedTile.GetComponent<Selectable> ();
		MainBehaviour.setTeam (capturedTileSBH, capturingUnit.team);
		oldTileTeam.land.Remove (capturedTileSBH);
		capturingUnit.team.land.Add (capturedTileSBH);

		capturingUnit.team.score += 30;

		if (
			//oldTileTeam.land.Count <= 0 ||
			oldTileTeam.land.FirstOrDefault(mb => mb.name == "Base") == null)
		{
			oldTileTeam.lost = true;
		}
	}

    private static void KillUnit(UnitBehaviour unitToDie)
    {
        OrderStatic.KillUnit(unitToDie.GetComponent<Selectable>());
    }

    public static Order Attack()
    {
        Order at = new Order();
        at.Title = "Attack";
        at.Movable = false;
        at.Uses = 1;
        at.Regenerate = 1;
        at.Range = 1;
        at.Targeting = TargetType.Target;
		//at.NoiseGeneration = 3;

        at.NecessaryOrderLevel = OrderLevel.C | OrderLevel.D | OrderLevel.E | OrderLevel.F;

		at.ActiveAction = new Action<Selectable, Selectable>((self, target) =>
        {
            PlayerBehaviour attackerTeam = self.team.GetComponent<PlayerBehaviour>();
            UnitBehaviour selfUnit = self.GetComponent<UnitBehaviour>();
            UnitBehaviour targetUnit = target.GetComponent<UnitBehaviour>();

			List<AnimationInstruction> instructions = new List<AnimationInstruction>();
			
			// create rotation instructions.
			instructions.AddRange(createRotationInstruction(self,target));
			
			// add other instructions.

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Scaling,
				startScale = target.transform.localScale,
				endScale = target.transform.localScale * 1.5F,				
				duration = TimeSpan.FromMilliseconds(100)
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Position,
				startPosition = self.transform.position,
				endPosition = GameFieldBehaviour.placeHexagon(target.GetComponent<Selectable>().positionQ, target.GetComponent<Selectable>().positionR, 1),
				
				duration = TimeSpan.FromMilliseconds(300)
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Position |  InstructionDef.Scaling,
				startPosition = GameFieldBehaviour.placeHexagon(target.GetComponent<Selectable>().positionQ, target.GetComponent<Selectable>().positionR, 1),
				endPosition = self.transform.position,
				startScale = target.transform.localScale * 1.5F ,
				endScale = target.transform.localScale ,
				duration = TimeSpan.FromMilliseconds(300),
			} );


            GameObject.Find("Main").GetComponent<MainBehaviour>().initiateAnimation(
                () =>{
                    
                    targetUnit.energy = MainBehaviour.damageCalculation(selfUnit, targetUnit);

                    // All effective damage goes to kill. Overkill gets substracted later.
                    attackerTeam.score += (selfUnit.currentAttackStrength) / (int)targetUnit.hexPosition.cover;

                    // check if defender survived.
                    if (targetUnit.energy <= 0)
                    {
                        KillUnit(targetUnit);
                        //subtracting the overkill from earlier attack score, plus ten for the kill itself;
                        attackerTeam.score += 10 + targetUnit.energy;
                    }
//                    else
//                    {
//                        targetUnit.updateInfo();
//                    }
                    //MainBehaviour.rotateUnit(self, target.GetComponent<Selectable>());
				//TODO: current noise system is ugly.

				noisening(self, self.currentLoudness +1);
				noisening(target, 1);
                    },
                self.gameObject,
			instructions.ToArray()
                );		

            self.availableOrders = self.availableOrders | at.NecessaryOrderLevel;
        });

		at.ValidTarget = new Func<Selectable, Selectable, Boolean>((self, target) =>
        {
            Selectable targetSB = target.GetComponent<Selectable>();

			return (target != null && target.team != self.team &&  target != self && target.GetComponent<UnitBehaviour>() != null && !(GameFieldBehaviour.NavigationBuddy.hexDistance(self.positionQ, self.positionR, targetSB.positionQ, targetSB.positionR) > at.Range));
        });

		at.Usable = new Func<Selectable, Selectable, Boolean>((self, target) =>
        {
            return !(self.availableOrders.SameFlags(at.NecessaryOrderLevel));
        });

        at.PassiveAction = new Action<Selectable>((self) =>
                                                              {
                                                              });
        return at;
    }

	public static Order Capture()
	{
		Order cp = new Order();
		cp.Title = "Capture";
		cp.Movable = false;
		cp.Uses = -1;
		cp.Regenerate = 1;
		cp.Range = 0;
		cp.Targeting = TargetType.Self;
		
		cp.NecessaryOrderLevel = OrderLevel.B | OrderLevel.C | OrderLevel.D | OrderLevel.E | OrderLevel.F;
		
		cp.ActiveAction = new Action<Selectable, Selectable>((self, target) =>
		                                                     {
//			PlayerBehaviour attackerTeam = self.team.GetComponent<PlayerBehaviour>();
//			UnitBehaviour selfUnit = self.GetComponent<UnitBehaviour>();
			UnitBehaviour targetUnit = target.GetComponent<UnitBehaviour>();
			
			List<AnimationInstruction> instructions = new List<AnimationInstruction>();
			

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Position |  InstructionDef.Scaling,
				startPosition = self.transform.position,
				endPosition = new Vector3(self.transform.position.x,self.transform.position.y + 5,self.transform.position.z),

				startScale = target.transform.localScale   ,
				endScale = target.transform.localScale* 1.1F ,
				duration = TimeSpan.FromMilliseconds(300),
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.None,
				duration = TimeSpan.FromMilliseconds(100),
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Position,
				startPosition = new Vector3(self.transform.position.x,self.transform.position.y + 5,self.transform.position.z),
				endPosition = self.transform.position,

				duration = TimeSpan.FromMilliseconds(100),
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Position,
				startPosition = self.transform.position,
				endPosition = new Vector3(self.transform.position.x,self.transform.position.y + 5,self.transform.position.z),

				duration = TimeSpan.FromMilliseconds(200),
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Position,
				startPosition = new Vector3(self.transform.position.x,self.transform.position.y + 5,self.transform.position.z),
				endPosition = self.transform.position,
				
				duration = TimeSpan.FromMilliseconds(100),
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Position,
				startPosition = self.transform.position,
				endPosition = new Vector3(self.transform.position.x,self.transform.position.y + 5,self.transform.position.z),
				
				duration = TimeSpan.FromMilliseconds(200),
			} );
			
			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Position,
				startPosition = new Vector3(self.transform.position.x,self.transform.position.y + 5,self.transform.position.z),
				endPosition = self.transform.position,
				
				duration = TimeSpan.FromMilliseconds(100),
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.None,
				duration = TimeSpan.FromMilliseconds(300),
			} );

			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Scaling,
				startScale = target.transform.localScale * 1.1F ,
				endScale = target.transform.localScale  ,
				duration = TimeSpan.FromMilliseconds(300),
			} );
			
			GameObject.Find("Main").GetComponent<MainBehaviour>().initiateAnimation(
				() =>{

				captureLand(self);

				//TODO: current noise system is ugly.
				noisening(self, self.currentLoudness + 5);
			},
			self.gameObject,
			instructions.ToArray()
			);		

			//Set order as used
			self.availableOrders = self.availableOrders | cp.NecessaryOrderLevel;
		});
		
		cp.ValidTarget = new Func<Selectable, Selectable, Boolean>((self, target) =>
		                                                           {			
			return (target != null && target == self && 
			        target.GetComponent<UnitBehaviour>().hexPosition.hexTileDefintion != HextTileDefinitions.classic &&
			        !(GameFieldBehaviour.NavigationBuddy.hexDistance(self.positionQ, self.positionR, target.positionQ, target.positionR) > cp.Range));
		});
		
		cp.Usable = new Func<Selectable, Selectable, Boolean>((self, target) =>
		                                                      {
			return ( 
			        self.GetComponent<UnitBehaviour>().hexPosition.hexTileDefintion != HextTileDefinitions.classic && 
			        !(self.availableOrders.SameFlags(cp.NecessaryOrderLevel) || self.GetComponent<UnitBehaviour>().hexPosition.GetComponent<Selectable>().team == self.team));
		});
		
		cp.PassiveAction = new Action<Selectable>((self) =>
		                                          {
		});
		return cp;
	}

	private static IEnumerable<AnimationInstruction> createRotationInstruction(Selectable self, Selectable target)
	{
		Transform childToRotate = self.transform.FindChild ("Model");

		// finding the turn direction and amount of turns.
		int turnDegrees = MainBehaviour.rotateEulDegrees(self,target) - Convert.ToInt32(childToRotate.eulerAngles.y) ;


		if (turnDegrees < 0) {
			turnDegrees += 360;
				}
		else
		if (turnDegrees > 360) {
			turnDegrees -= 360 ;
		}		

		//turn in the opposite direction
				//if (turnDegrees > Convert.ToInt32(ChildToRotate.eulerAngles.y) - 180) {
		if (turnDegrees > 180) {
					turnDegrees = -( 360 - turnDegrees);
				}


		// get the number of turns by degree
		int turnCount = Mathf.Abs( turnDegrees  / 60);
		
		float toRotateSteps = 0;

		List <AnimationInstruction> instructions = new List<AnimationInstruction> (turnCount);
		
		for (int i = 1; i <= turnCount; i++) {
			Vector3 sRotation =  new Vector3(
				childToRotate.eulerAngles.x, 
				childToRotate.eulerAngles.y + 
				toRotateSteps ,
				childToRotate.eulerAngles.z
				);
			toRotateSteps += (turnDegrees / turnCount);
			Vector3 eRotation = new Vector3(
				childToRotate.eulerAngles.x,
				childToRotate.eulerAngles.y +
				toRotateSteps ,
				childToRotate.eulerAngles.z
				);
			instructions.Add(new AnimationInstruction() { 
				instructionDef = InstructionDef.Rotation,
				startRotation = sRotation,
				endRotation = eRotation,
				
				duration = TimeSpan.FromMilliseconds(150)
			} );
		}
		return instructions;
		}

    public static Order Move()
    {
        Order mov = new Order();
        mov.Title = "Move";
        mov.Movable = false;
        mov.Uses = 1;
        mov.Regenerate = 1;
        mov.Range = 1;
        mov.Targeting = TargetType.Target;
        mov.NecessaryOrderLevel = OrderLevel.B;

		mov.ActiveAction = new Action<Selectable, Selectable>((self, target) =>
        {
            //moving code
            HexTileBehaviour targetHexFieldHTB = target.GetComponent<HexTileBehaviour>();
			Selectable targetHexFieldSB = target.GetComponent<Selectable>();

			List<AnimationInstruction> instructions = new List<AnimationInstruction>();

			// create rotation instructions.
			instructions.AddRange(createRotationInstruction(self,target));
		
			// add other instructions.
			instructions.Add(new AnimationInstruction() { 
									instructionDef = InstructionDef.Position,
									startPosition = self.transform.position,
									endPosition = GameFieldBehaviour.placeHexagon(target.GetComponent<Selectable>().positionQ, target.GetComponent<Selectable>().positionR, 1),
									duration = TimeSpan.FromMilliseconds(200)
			} );
			
			GameObject.Find("Main").GetComponent<MainBehaviour>().initiateAnimation(
				()=>
				{
                    MainBehaviour.positionUnit(self, targetHexFieldHTB);                   
				noisening(self, self.currentLoudness + 5);
                    },
				self.gameObject,
			instructions.ToArray()
				);



            // setting the order as used.
            self.availableOrders = self.availableOrders | mov.NecessaryOrderLevel;
        });

        mov.PassiveAction = new Action<Selectable>((self) =>
                                                         {
                                                         });

		mov.Usable = new Func<Selectable, Selectable, Boolean>((self, target) =>
        {
            return !(self.availableOrders.SameFlags(mov.NecessaryOrderLevel));
        });

		mov.ValidTarget = new Func<Selectable, Selectable, Boolean>((self, target) =>
        {
            HexTileBehaviour targetTile = target.GetComponent<HexTileBehaviour>();
            Selectable targetHexFieldSB = target.GetComponent<Selectable>();
            return (targetTile != null && targetTile.containedUnit == null && (GameFieldBehaviour.NavigationBuddy.hexDistance(self.positionQ, self.positionR, targetHexFieldSB.positionQ, targetHexFieldSB.positionR) <= mov.Range));
        });

        return mov;
    }


    public static Order HealthKit()
    {
        Order hk = new Order();
        hk.Title = "Health Kit";        
    
        hk.Movable = true;
        hk.Uses = 3;
        hk.NecessaryOrderLevel = OrderLevel.C;
        hk.Targeting = TargetType.Self;// | TargetType.TargetFriendly;

		hk.ActiveAction = new Action<Selectable, Selectable>((self, target) =>
        {
            UnitBehaviour unitBehav = self.GetComponent<UnitBehaviour>();
            unitBehav.energy = Math.Min(unitBehav.energy + 50, unitBehav.energyLimit);
            hk.Uses -= 1;
            //unitBehav.updateInfo();
			self.availableOrders = self.availableOrders | hk.NecessaryOrderLevel;
        });

        hk.PassiveAction = new Action<Selectable>((self) =>
                                                          {
                                                          });

		hk.Usable = new Func<Selectable, Selectable, Boolean>((self, target) =>
                                                                {
                                                                    UnitBehaviour unitSelf = self.GetComponent<UnitBehaviour>();
                                                                    return (unitSelf.energy < unitSelf.energyLimit);
                                                                });

		hk.ValidTarget = new Func<Selectable, Selectable, Boolean>((self, target) =>
                                                                   {
                                                                       return (self == target);
                                                                   });

        return hk;
    }

    public static Order Silencer()
    {
        Order sil = new Order();
        sil.Title = "Silencer";
        sil.Movable = true;
        sil.Uses = 5;
        sil.Targeting = TargetType.Self;
        sil.NecessaryOrderLevel = OrderLevel.E;

		sil.ActiveAction = new Action<Selectable, Selectable>((self, target) =>
                                                                {
                                                                    //Switching silencers on and off.
                                                                    sil.PassiveRunning = !sil.PassiveRunning;
                                                                    //activating silencers costs order level.
                                                                    if (sil.PassiveRunning)
                                                                    {
                                                                        self.availableOrders = self.availableOrders | sil.NecessaryOrderLevel;
                                                                    }
                                                                });

        sil.PassiveAction = new Action<Selectable>((self) =>
        {//TODO: Silencer stuff.

            if (sil.PassiveRunning && sil.Usable(self, null))
            {
                self.currentLoudness -= 3;
                sil.Uses -= 1;
            }
        });

		sil.Usable = new Func<Selectable, Selectable, Boolean>((self, target) =>
                                                              {
                                                                  bool res = (sil.Uses > 0);
                                                                  if (!res)
                                                                  {
                                                                      sil.PassiveRunning = res;
                                                                  }
                                                                  return res;
                                                              });

		sil.ValidTarget = new Func<Selectable, Selectable, Boolean>((self, target) =>
                                                                   {
                                                                       return (self == target);
                                                                   });
        return sil;
    }

    public static Order Grenade()
    {
        Order grn = new Order();
        grn.Title = "Grenade";
        grn.Movable = false;
        grn.Uses = 1;
        grn.Regenerate = 0;
        grn.Range = 2;
        grn.Targeting = TargetType.Target;

        grn.NecessaryOrderLevel = OrderLevel.A | OrderLevel.B | OrderLevel.C | OrderLevel.D | OrderLevel.E | OrderLevel.F;

		grn.ActiveAction = new Action<Selectable, Selectable>((self, target) =>
                                                             {
                                                                 PlayerBehaviour attackerTeam = self.team.GetComponent<PlayerBehaviour>();
                                                                 UnitBehaviour selfUnit = self.GetComponent<UnitBehaviour>();
                                                                 UnitBehaviour targetUnit = target.GetComponent<UnitBehaviour>();

                                                                 targetUnit.energy -= (selfUnit.currentAttackStrength) * 2 / (int)targetUnit.hexPosition.cover;

                                                                 // All effective damage goes to kill. Overkill gets substracted later.
                                                                 attackerTeam.score += (selfUnit.currentAttackStrength) * 2 / (int)targetUnit.hexPosition.cover;

                                                                 // check if defender survived.
                                                                 if (targetUnit.energy <= 0)
                                                                 {
                                                                     KillUnit(targetUnit);
                                                                     //subtracting the overkill from earlier attack score, plus ten for the kill itself;
                                                                     attackerTeam.score += 10 + targetUnit.energy;
                                                                 }
                                                                 else
                                                                 {
                                                                     //targetUnit.updateInfo();
                                                                 }

                                                                 // code for spread damage.
                                                                 Selectable targetSB = target.GetComponent<Selectable>();

                                                                 foreach (Selectable possibleEnemy in targetSB.NeighbouringUnits)
                                                                 {

                                                                     UnitBehaviour hitEnemyUB = possibleEnemy.GetComponent<UnitBehaviour>();
                                                                     // check if it is really a unit and also from the same team like the target.
                                                                     if (hitEnemyUB != null && possibleEnemy.team == targetSB.team)
                                                                     {
                                                                         hitEnemyUB.energy -= (selfUnit.currentAttackStrength) / (int)hitEnemyUB.hexPosition.cover;
                                                                         attackerTeam.score += (selfUnit.currentAttackStrength) / (int)hitEnemyUB.hexPosition.cover;
                                                                         if (hitEnemyUB.energy <= 0)
                                                                         {
                                                                             KillUnit(hitEnemyUB);
                                                                             //subtracting the overkill from earlier attack score, plus ten for the kill itself;
                                                                             attackerTeam.score += 10 + hitEnemyUB.energy;
                                                                         }
                                                                         else
                                                                         {
                                                                             //hitEnemyUB.updateInfo();
                                                                         }
                                                                     }
                                                                 }

                                                                 //TODO: current noise system is ugly.
                                                                 noisening(self, self.currentLoudness);
                                                                 noisening(target,10);
			grn.Uses -=1;

                                                                 self.availableOrders = self.availableOrders | grn.NecessaryOrderLevel;
                                                             });

		grn.ValidTarget = new Func<Selectable, Selectable, Boolean>((self, target) =>
                                                                   {
                                                                       Selectable targetSB = target.GetComponent<Selectable>();

                                                                       return (target != null &&
			        self.team != target.team && 
			        target.GetComponent<UnitBehaviour>() != null && 
			        (GameFieldBehaviour.NavigationBuddy.hexDistance(self.positionQ, self.positionR, targetSB.positionQ, targetSB.positionR) <= grn.Range));
                                                                   });

		grn.Usable = new Func<Selectable, Selectable, Boolean>((self, target) =>
                                                              {
                                                                  return (grn.Uses > 0) && !(self.availableOrders.SameFlags(grn.NecessaryOrderLevel));
                                                              });

        grn.PassiveAction = new Action<Selectable>((self) =>
                                                  {

                                                  });

        return grn;
    }

    public static CoverOrder SandBags()
    {
        CoverOrder sb = new CoverOrder();
        sb.Title = "SandBags";
        sb.Movable = false;
        sb.Uses = 10;
        sb.Targeting = TargetType.Self;
        sb.NecessaryOrderLevel = OrderLevel.E;
        sb.CoverBonus = Cover.extreme;

		sb.ActiveAction = new Action<Selectable, Selectable>((self, target) =>
                                                              {
                                                                  //Switching silencers on and off.
                                                                  sb.PassiveRunning = !sb.PassiveRunning;
                                                                  //activating silencers costs order level.
                                                                  if (sb.PassiveRunning)
                                                                  {
                                                                      self.availableOrders = self.availableOrders | sb.NecessaryOrderLevel;
                                                                  }
                                                              });

        sb.PassiveAction = new Action<Selectable>((self) =>
                                                   {
                                                       if (sb.PassiveRunning && sb.Usable(self, null))
                                                       {
                                                           //  int oldCover = (int)self.GetComponent<HexTileBehaviour>().cover;
                                                           self.GetComponent<HexTileBehaviour>().cover = sb.CoverBonus;

                                                           sb.Uses -= 1;
                                                       }
                                                       else
                                                       {
                                                           HexTileBehaviour res = (GameObject.Find("Main").GetComponent<MainBehaviour>().hexTileTypes.FirstOrDefault(
                                                               (HexTileBehaviour ht) => ht.hexTileDefintion == self.GetComponent<HexTileBehaviour>().hexTileDefintion)
                                                                                   );
                                                           self.GetComponent<HexTileBehaviour>().cover = res.cover;
                                                       }
                                                   });

		sb.Usable = new Func<Selectable, Selectable, Boolean>((self, target) =>
                                                               {
                                                                   HexTileBehaviour resTile = (GameObject.Find("Main").GetComponent<MainBehaviour>().hexTileTypes.FirstOrDefault(
                                                                       (HexTileBehaviour ht) => ht.hexTileDefintion == self.GetComponent<HexTileBehaviour>().hexTileDefintion)
                                                                       );

                                                                   bool res = (sb.Uses > 0 && resTile.cover < sb.CoverBonus);
                                                                   if (!res)
                                                                   {
                                                                       sb.PassiveRunning = res;
                                                                   }
                                                                   return res;
                                                               });

		sb.ValidTarget = new Func<Selectable, Selectable, Boolean>((self, target) =>
                                                                    {
                                                                        return (self == target);
                                                                    });
        return sb;
    }
}

[Flags]
public enum TargetType
{
    Global = 1,
    Self = 2,
    Target = 4,
    TargetFriendly = 8,
}


